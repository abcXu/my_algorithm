### 一、二叉树的递归遍历

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

#### 二叉树的指针形式

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

#### 1、前序遍历

```cpp
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

#### 2、中序遍历

```cpp
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}
```

#### 3、后序遍历

```cpp
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```

### 二、二叉树的迭代遍历

#### 1、前序遍历 

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node->val);	// 读取节点的值
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return result;
    }
};
```

#### 2、中序遍历

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```

#### 3、后序遍历

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
```

### 三、层序遍历

#### 1、自上向底

采用广度优先算法进行遍历

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if(root!=NULL) que.push(root);
        else return {};
        
        vector<vector<int>> result;
        while(!que.empty())
        {
            int size = que.size();
            vector<int> vec;
             // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            while(size--)	// 使用while循环优于for循环	
            {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);

            }
            result.push_back(vec);
        }
        return result;
    }
};
```

#### 2、自底向上

解法同上只要将 **自上向底**的result给reverse即可

```cpp
 reverse(result.begin(), result.end()); // 在这里反转一下数组即可
```

 ####  3、最右视图

在层序遍历时判断是否为最后一个节点

```cpp
class Solution {class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<int> result;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == (size - 1)) result.push_back(node->val); // 将每一层的最后元素放入result数组中
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

#### 4、每一层的均值

只需要在层序遍历时直接统计每一层的均值即可

``` cpp
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode*> que;
        if(root!=NULL) que.push(root);
        else return {};
        vector<double> result;
        while(!que.empty())
        {
            int size = que.size();
            double sum = 0;
            for(int i=0;i<size; i++)
            {
                TreeNode* node = que.front();
                que.pop();
                sum+=node->val;	// 求每一层的总和
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            result.push_back(sum/size);	// 取均值
        }
        return result;
    }
};
```

#### 5、多叉树的层序遍历

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {    // bfs
       if(root==NULL) return {};

       queue<Node*> que;
       if(root) que.push(root);
       else return {};
       vector<vector<int>> result;

       while(!que.empty()){
          int size = que.size();
          vector<int> vec;
          for(int i = 0;i<size;i++)
          {
            Node* node = que.front();
            que.pop();
            vec.push_back(node->val);
            for (int i = 0; i < node->children.size(); i++) { // 将节点孩子们加入队列
                if (node->children[i]) que.push(node->children[i]);
            }
          }
          result.push_back(vec);
       }
       return result;

    }
};
```

#### 6、填充每个节点的下一个右侧节点

遍历每一层时分首节点和非首节点进行处理

```cpp
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if(root!=NULL) que.push(root);
        else return NULL;
        while(!que.empty()){
            int size = que.size();
            Node* nodePre;
            Node* node;
            for(int i = 0;i < size; i++)
            {
                if(i==0){      // 本层的第一个节点
                    nodePre = que.front();
                    que.pop();
                    node = nodePre;
                }else{  // 非首节点
                    node = que.front();
                    que.pop();
                    nodePre->next = node;
                    nodePre = nodePre->next;

                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            nodePre->next = NULL;   // 本层的最后一个节点指向NULL
        }
        return root;
    }
};
```

#### 7、二叉树的最大深度

迭代法：

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
       int depth = 0;
       queue<TreeNode*> que;
       if(root!=NULL) que.push(root);
       else return 0;
       while(!que.empty())
       {
           int size = que.size();
           for(int i = 0;i<size;i++)
           {
               TreeNode* node = que.front();
               que.pop();
               if(node->left) que.push(node->left);
               if(node->right) que.push(node->right);

           }
           depth++; // 遍历完每一层深度++
       }
       return depth;
    }
};
```



递归法：

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
       return root?1+max(maxDepth(root->left),maxDepth(root->right)):0;
    }
};
```

#### 8、二叉树的最小深度

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
       int depth = 0;
       queue<TreeNode*> que;
       if(root!=NULL) que.push(root);
       else return 0;
       while(!que.empty())
       {
           int size = que.size();
           depth++; // 遍历完每一层深度++
           for(int i = 0;i<size;i++)
           {
               TreeNode* node = que.front();
               que.pop();
               if(!node->right&&!node->left) return depth;
               if(node->left) que.push(node->left);
               if(node->right) que.push(node->right);
              
           }
         
       }
       return depth;
    }
};
```





